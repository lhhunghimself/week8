<!-- Generated by SpecStory -->

# GitHub Actions Workflow for EC2 Deployment (2025-05-23 21:55:53)

_**User**_

create a file .github/workflows/cd.yml which will deploy the workflow on the ec2 instance which executes on a manual invoke. .Log into the ec2 instance using my pem file, and see if the github repo directory exists. If it does not, clone it. If it does cd to it. If there is a docker-compose set up and running run docker-compose down. Then pull the latest changes and run docker compose up in production mode, building the latest changes. Create .env from secrets in github. 

---

_**Assistant**_

Below is a new GitHub Actions workflow that you can add at `.github/workflows/cd.yml`. It runs on manual dispatch, SSH’s into your EC2 box using the private key you’ve stored in `SSH_PRIVATE_KEY`, ensures the repo is cloned (or updated), brings down any existing Docker-Compose services, regenerates the `.env` from your GitHub secrets, and then spins everything back up in production mode.

Make sure you’ve added the following repository **secrets** in Settings → Secrets:

- `SSH_PRIVATE_KEY` – the contents of your `.pem` file  
- `EC2_HOST` – your EC2 public IP or DNS  
- `EC2_USER` – the SSH user (e.g. `ubuntu` or `ec2-user`)  
- `REPO_DIR` – the path on EC2 where the repo should live (e.g. `/home/ubuntu/webapp`)  
- All your app’s runtime secrets:  
  `SECRET_KEY`, `GITHUB_OAUTH_CLIENT_ID`, `GITHUB_OAUTH_CLIENT_SECRET`,  
  `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB`, `POSTGRES_PORT`,  
  `MAPBOX_ACCESS_TOKEN`, `TRIPADVISOR_API_KEY`  

```yaml:.github/workflows/cd.yml
name: CD

on:
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest

    steps:
      # 1. Install your private key into ~/.ssh/id_rsa
      - name: Install SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      # 2. SSH into EC2 and run the deployment script
      - name: Deploy to EC2
        env:
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          REPO_DIR: ${{ secrets.REPO_DIR }}
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa $EC2_USER@$EC2_HOST << 'EOF'
            set -e

            # Clone if missing, otherwise update
            if [ ! -d "$REPO_DIR" ]; then
              git clone https://github.com/${{ github.repository }}.git "$REPO_DIR"
            fi
            cd "$REPO_DIR"

            # Stop any running services
            if [ -f docker-compose.yml ]; then
              docker-compose down
            fi

            # Pull latest and reset to main
            git fetch --all
            git reset --hard origin/main

            # Recreate .env from GitHub secrets
            cat > .env << 'EOL'
            FLASK_APP="app.py"
            FLASK_DEBUG="0"
            SECRET_KEY="${{ secrets.SECRET_KEY }}"
            GITHUB_OAUTH_CLIENT_ID="${{ secrets.GITHUB_OAUTH_CLIENT_ID }}"
            GITHUB_OAUTH_CLIENT_SECRET="${{ secrets.GITHUB_OAUTH_CLIENT_SECRET }}"
            OAUTHLIB_INSECURE_TRANSPORT="1"
            POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
            POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
            POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
            POSTGRES_PORT="${{ secrets.POSTGRES_PORT }}"
            MAPBOX_ACCESS_TOKEN="${{ secrets.MAPBOX_ACCESS_TOKEN }}"
            TRIPADVISOR_API_KEY="${{ secrets.TRIPADVISOR_API_KEY }}"
            EOL

            # Build & launch in production profile
            docker-compose up -d --build --remove-orphans --profile production
          EOF
```

Explanation of key parts:

1. **workflow_dispatch** — allows you to trigger this workflow manually from the Actions tab.  
2. **SSH setup** — writes your PEM key into `~/.ssh/id_rsa` and restricts permissions.  
3. **Idempotent deploy script** on the EC2 host:
   - Clones the repo if missing, else does a hard-reset to `origin/main`
   - Brings down any running Compose stack
   - Generates a fresh `.env` from your GitHub Secrets
   - Builds and starts the services in `production` profile  

Once you’ve committed this file and pushed, go to **Actions → CD → Run workflow**, supply any parameters if you add them later, and hit **Run workflow**. That’ll kick off the zero-downtime deploy on your EC2 instance.

---

_**User**_

I get the error "Run ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa $EC2_USER@$EC2_HOST << 'EOF'
  ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa $EC2_USER@$EC2_HOST << 'EOF'
    set -e
    echo "REPO_DIR: $REPO_DIR"
    # Clone if missing, otherwise update
    if [ ! -d "$REPO_DIR" ]; then
      git clone https://github.com/lhhunghimself/week8.git "$REPO_DIR"
    fi
    cd "$REPO_DIR"
  
    # Stop any running services
    if [ -f docker-compose.yml ]; then
      docker-compose down
    fi
  
    # Pull latest and reset to main
    git fetch --all
    git reset --hard origin/main
  
    # Recreate .env from GitHub secrets
    cat > .env << 'EOL'
    FLASK_APP="app.py"
    FLASK_DEBUG="0"
    SECRET_KEY="***"
    GITHUB_OAUTH_CLIENT_ID=""
    GITHUB_OAUTH_CLIENT_SECRET=""
    OAUTHLIB_INSECURE_TRANSPORT="1"
    POSTGRES_USER="***"
    POSTGRES_PASSWORD="***"
    POSTGRES_DB="***"
    POSTGRES_PORT="***"
    MAPBOX_ACCESS_TOKEN="***"
    TRIPADVISOR_API_KEY="***"
    EOL
  
    # Build & launch in production profile
    docker-compose up -d --build --remove-orphans --profile production
  EOF 
  shell: /usr/bin/bash -e {0}
  env:
    EC2_USER: ***
    EC2_HOST: ***
  
    REPO_DIR: ***
/home/runner/work/_temp/9ef5e237-0144-4e6c-915f-1a456920d661.sh: line 37: warning: here-document at line 1 delimited by end-of-file (wanted `EOF')
Pseudo-terminal will not be allocated because stdin is not a terminal.
Warning: Permanently added '***' (ED25519) to the list of known hosts.
Welcome to Ubuntu 24.04.2 LTS (GNU/Linux 6.8.0-1024-aws x86_64)

 * Documentation:  https://help.***.com
 * Management:     https://landscape.canonical.com
 * Support:        https://***.com/pro

 System information as of Sat May 24 06:05:18 UTC 2025

  System load:  0.0                Processes:             130
  Usage of /:   28.4% of 28.02GB   Users logged in:       1
  Memory usage: 47%                IPv4 address for enX0: 172.31.17.217
  Swap usage:   0%

 * Ubuntu Pro delivers the most comprehensive open source security and
   compliance features.

   https://***.com/aws/pro

Expanded Security Maintenance for Applications is not enabled.

43 updates can be applied immediately.
To see these additional updates run: apt list --upgradable

Enable ESM Apps to receive additional future security updates.
See https://***.com/esm or run: sudo pro status


*** System restart required ***
REPO_DIR: 
fatal: could not create work tree dir '': No such file or directory
Error: Process completed with exit code 128." 

---

_**Assistant**_

# Fixing the Environment Variable Issue in GitHub Actions

It looks like the environment variables aren't being properly passed into the SSH session. This is happening because of how heredocs work with single quotes (`'EOF'`). When you use single quotes, variables don't get expanded inside the heredoc.

Let's fix the workflow file:

```yaml:.github/workflows/cd.yml
name: CD

on:
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest

    steps:
      # 1. Install your private key into ~/.ssh/id_rsa
      - name: Install SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      # 2. SSH into EC2 and run the deployment script
      - name: Deploy to EC2
        env:
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          REPO_DIR: ${{ secrets.REPO_DIR }}
        run: |
          # Pass environment variables directly to SSH command
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa $EC2_USER@$EC2_HOST "
            set -e
            
            # Use the directly passed variables
            REPO_DIR='$REPO_DIR'
            echo \"REPO_DIR: \$REPO_DIR\"
            
            # Clone if missing, otherwise update
            if [ ! -d \"\$REPO_DIR\" ]; then
              git clone https://github.com/${{ github.repository }}.git \"\$REPO_DIR\"
            fi
            cd \"\$REPO_DIR\"

            # Stop any running services
            if [ -f docker-compose.yml ]; then
              docker-compose down
            fi

            # Pull latest and reset to main
            git fetch --all
            git reset --hard origin/main

            # Recreate .env from GitHub secrets
            cat > .env << 'EOL'
            FLASK_APP=\"app.py\"
            FLASK_DEBUG=\"0\"
            SECRET_KEY=\"${{ secrets.SECRET_KEY }}\"
            GITHUB_OAUTH_CLIENT_ID=\"${{ secrets.GITHUB_OAUTH_CLIENT_ID }}\"
            GITHUB_OAUTH_CLIENT_SECRET=\"${{ secrets.GITHUB_OAUTH_CLIENT_SECRET }}\"
            OAUTHLIB_INSECURE_TRANSPORT=\"1\"
            POSTGRES_USER=\"${{ secrets.POSTGRES_USER }}\"
            POSTGRES_PASSWORD=\"${{ secrets.POSTGRES_PASSWORD }}\"
            POSTGRES_DB=\"${{ secrets.POSTGRES_DB }}\"
            POSTGRES_PORT=\"${{ secrets.POSTGRES_PORT }}\"
            MAPBOX_ACCESS_TOKEN=\"${{ secrets.MAPBOX_ACCESS_TOKEN }}\"
            TRIPADVISOR_API_KEY=\"${{ secrets.TRIPADVISOR_API_KEY }}\"
            EOL

            # Build & launch in production profile
            docker-compose up -d --build --remove-orphans --profile production
          "
```

## Key Changes Made

1. **Removed the heredoc approach** (`<< 'EOF'`) entirely and replaced it with a quoted command string
2. **Variables explicitly passed** - The environment variables are now directly passed into the command string
3. **Proper escaping** - Double quotes are escaped with backslashes where needed
4. **Explicitly setting REPO_DIR** - Setting the variable again inside the SSH session

This approach ensures that your GitHub environment variables are correctly passed to the remote shell while maintaining the ability to set up the proper environment on your EC2 instance.

If this still doesn't work, there's an alternative approach we could try using sshpass or writing a script file and copying it to the remote server first, then executing it.

---

_**User**_

EOL is not being recognize as the end of the .env file

---

_**Assistant**_



I see the issue. The problem is with the heredoc format inside the SSH command. Let's fix the `.github/workflows/cd.yml` file to properly handle the .env file creation:

```yaml:.github/workflows/cd.yml
name: CD

on:
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest

    steps:
      # 1. Install your private key into ~/.ssh/id_rsa
      - name: Install SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      # 2. SSH into EC2 and run the deployment script
      - name: Deploy to EC2
        env:
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          REPO_DIR: ${{ secrets.REPO_DIR }}
        run: |
          # Create a temporary .env file locally
          cat > temp_env_file << EOF
          FLASK_APP="app.py"
          FLASK_DEBUG="0"
          SECRET_KEY="${{ secrets.SECRET_KEY }}"
          GITHUB_OAUTH_CLIENT_ID="${{ secrets.GITHUB_OAUTH_CLIENT_ID }}"
          GITHUB_OAUTH_CLIENT_SECRET="${{ secrets.GITHUB_OAUTH_CLIENT_SECRET }}"
          OAUTHLIB_INSECURE_TRANSPORT="1"
          POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
          POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
          POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
          POSTGRES_PORT="${{ secrets.POSTGRES_PORT }}"
          MAPBOX_ACCESS_TOKEN="${{ secrets.MAPBOX_ACCESS_TOKEN }}"
          TRIPADVISOR_API_KEY="${{ secrets.TRIPADVISOR_API_KEY }}"
          EOF
          
          # Copy the .env file to the server
          scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa temp_env_file $EC2_USER@$EC2_HOST:/tmp/env_file
          
          # Run the deployment commands
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa $EC2_USER@$EC2_HOST "
            set -e
            
            # Use directly passed variables
            REPO_DIR='$REPO_DIR'
            echo \"REPO_DIR: \$REPO_DIR\"
            
            # Clone if missing, otherwise update
            if [ ! -d \"\$REPO_DIR\" ]; then
              git clone https://github.com/${{ github.repository }}.git \"\$REPO_DIR\"
            fi
            cd \"\$REPO_DIR\"

            # Stop any running services
            if [ -f docker-compose.yml ]; then
              docker-compose down
            fi

            # Pull latest and reset to main
            git fetch --all
            git reset --hard origin/main

            # Copy the env file from /tmp
            cp /tmp/env_file .env
            rm /tmp/env_file

            # Build & launch in production profile
            docker-compose up -d --build --remove-orphans --profile production
          "
          
          # Clean up local temp file
          rm temp_env_file
```

## Key Changes:

1. **Created the .env file locally** first as `temp_env_file`
2. **Used SCP to copy** the .env file to the server at `/tmp/env_file`
3. **Simplified the SSH commands** by removing the heredoc inside SSH
4. **Added cleanup steps** to remove temporary files

This approach:
- Avoids the nested heredoc issue entirely
- Allows GitHub secrets to expand properly in the local environment
- Ensures the .env file has the correct format and content
- Is more secure since we only temporarily store the .env file in /tmp

Try this approach and it should resolve your issue with the EOL delimiter not being recognized.

---

_**User**_

# Create a temporary .env file locally
3
  cat > temp_env_file << EOF
4
  FLASK_APP="app.py"
5
  FLASK_DEBUG="0"
6
  SECRET_KEY="***"
7
  GITHUB_OAUTH_CLIENT_ID=""
8
  GITHUB_OAUTH_CLIENT_SECRET=""
9
  OAUTHLIB_INSECURE_TRANSPORT="1"
10
  POSTGRES_USER="***"
11
  POSTGRES_PASSWORD="***"
12
  POSTGRES_DB="***"
13
  POSTGRES_PORT="***"
14
  MAPBOX_ACCESS_TOKEN="***"
15
  TRIPADVISOR_API_KEY="***"
16
  EOF
17
  
18
  # Copy the .env file to the server
19
  scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa temp_env_file $EC2_USER@$EC2_HOST:/tmp/env_file
20
  
21
  # Run the deployment commands
22
  ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa $EC2_USER@$EC2_HOST "
23
    set -e
24
    
25
    # Use directly passed variables
26
    REPO_DIR='$REPO_DIR'
27
    echo \"REPO_DIR: \$REPO_DIR\"
28
    
29
    # Clone if missing, otherwise update
30
    if [ ! -d \"\$REPO_DIR\" ]; then
31
      git clone https://github.com/lhhunghimself/week8.git \"\$REPO_DIR\"
32
    fi
33
    cd \"\$REPO_DIR\"
34
  
35
    # Stop any running services
36
    if [ -f docker-compose.yml ]; then
37
      docker-compose down
38
    fi
39
  
40
    # Pull latest and reset to main
41
    git fetch --all
42
    git reset --hard origin/main
43
  
44
    # Copy the env file from /tmp
45
    cp /tmp/env_file .env
46
    rm /tmp/env_file
47
  
48
    # Build & launch in production profile
49
    docker-compose up -d --build --remove-orphans --profile production
50
  "
51
  
52
  # Clean up local temp file
53
  rm temp_env_file 
54
  shell: /usr/bin/bash -e {0}
55
  env:
56
    EC2_USER: ***
57
    EC2_HOST: ***
58
  
59
    REPO_DIR: ***
60
:/tmp/env_file: No such file or directory
61
Error: Process completed with exit code 1.

---

_**Assistant**_

Below is a more robust approach—no local temp files or SCP, just one SSH‐delivered script that:

- Expands `REPO_DIR` (and pulls in your GitHub‐secrets) **locally**  
- Runs **entire** deploy logic **remotely**  
- Uses a nested, quoted heredoc for **.env** so secrets land verbatim in the file  

```yaml:path=.github/workflows/cd.yml
# … the top of the file stays the same …
      - name: Deploy to EC2
        env:
          EC2_USER:        ${{ secrets.EC2_USER }}
          EC2_HOST:        ${{ secrets.EC2_HOST }}
          REPO_DIR:        ${{ secrets.REPO_DIR }}
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa $EC2_USER@$EC2_HOST bash -s <<EOF
            set -e

            #— locally‐expanded REPO_DIR passed in from step-env
            REPO_DIR="${REPO_DIR}"
            echo "REPO_DIR: \$REPO_DIR"

            # clone if missing, otherwise update
            if [ ! -d "\$REPO_DIR" ]; then
              git clone https://github.com/${{ github.repository }}.git "\$REPO_DIR"
            fi
            cd "\$REPO_DIR"

            # tear down any existing stack
            if [ -f docker-compose.yml ]; then
              docker-compose down --remove-orphans
            fi

            # get latest
            git fetch --all
            git reset --hard origin/main

            # write a fresh .env using your GitHub Secrets
            cat > .env << 'EOL'
FLASK_APP="app.py"
FLASK_DEBUG="0"
SECRET_KEY="${{ secrets.SECRET_KEY }}"
GITHUB_OAUTH_CLIENT_ID="${{ secrets.GITHUB_OAUTH_CLIENT_ID }}"
GITHUB_OAUTH_CLIENT_SECRET="${{ secrets.GITHUB_OAUTH_CLIENT_SECRET }}"
OAUTHLIB_INSECURE_TRANSPORT="1"
POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
POSTGRES_PORT="${{ secrets.POSTGRES_PORT }}"
MAPBOX_ACCESS_TOKEN="${{ secrets.MAPBOX_ACCESS_TOKEN }}"
TRIPADVISOR_API_KEY="${{ secrets.TRIPADVISOR_API_KEY }}"
EOL

            # build & launch production profile
            docker-compose up -d --build --remove-orphans --profile production
          EOF
# … rest of file unchanged …
```

What this does:

1. **`bash -s <<EOF`** streams a small deploy script into the EC2 shell.  
2. **`REPO_DIR="${REPO_DIR}"`** injects your runner’s `REPO_DIR` straight into that script.  
3. **`cat > .env << 'EOL'…EOL`** creates your `.env` remotely, with the actual secret values (inserted at workflow‐parse time).  
4. Finally, `docker-compose up -d … --profile production` rebuilds and restarts your stack.  

No more indent‐mistakes on nested heredocs or SCP pitfalls—everything runs in one shot over SSH.

---

_**User**_

the env file does not seem to be written properly

---

_**Assistant**_



---

