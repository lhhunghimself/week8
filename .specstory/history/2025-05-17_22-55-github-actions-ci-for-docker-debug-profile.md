<!-- Generated by SpecStory -->

# GitHub Actions CI for Docker Debug Profile (2025-05-17 15:55:49)

_**User**_

@docker-compose.yml Create a ci.yml github actions file that will launch the debug profile ie docker-compose --profile debug up. Have it check whether curl can connect with flask on port 80.

---

_**Assistant**_



---

I'll create a GitHub Actions workflow file to launch the debug profile and test connectivity to the Flask app.

---

```diff
- 
+ name: CI Testing
+ 
+ on:
+   push:
+     branches: [ main, master ]
+   pull_request:
+     branches: [ main, master ]
+ 
+ jobs:
+   test:
+     runs-on: ubuntu-latest
+     
+     steps:
+     - name: Check out code
+       uses: actions/checkout@v3
+     
+     - name: Set up Docker Buildx
+       uses: docker/setup-buildx-action@v2
+     
+     - name: Start services with docker-compose
+       run: |
+         docker-compose --profile debug up -d
+     
+     - name: Wait for services to be ready
+       run: |
+         # Wait for Flask app to become available
+         echo "Waiting for Flask app to start..."
+         timeout=60
+         counter=0
+         while ! curl -s http://localhost:80 > /dev/null; do
+           if [ $counter -eq $timeout ]; then
+             echo "Timed out waiting for Flask app"
+             docker-compose logs
+             exit 1
+           fi
+           echo "Still waiting for Flask app to be available... ($counter/$timeout)"
+           sleep 2
+           counter=$((counter + 2))
+         done
+         echo "Flask app is available!"
+     
+     - name: Test connection to Flask
+       run: |
+         response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:80)
+         if [ "$response" -ne 200 ]; then
+           echo "Failed to connect to Flask app, got HTTP status $response"
+           docker-compose logs
+           exit 1
+         fi
+         echo "Successfully connected to Flask app!"
+     
+     - name: Clean up
+       run: |
+         docker-compose --profile debug down
+       if: always() 
```

---

I've created a GitHub Actions workflow file that:

1. Runs on pushes and pull requests to main/master branches
2. Starts the debug profile with `docker-compose --profile debug up -d`
3. Waits for the Flask app to become available on port 80
4. Tests the connection to verify it returns a 200 status code
5. Cleans up by stopping all containers

The workflow includes a timeout mechanism that will fail the build after 60 seconds if the Flask app doesn't start properly, and it will show the Docker logs to help diagnose any issues.

---

_**User**_

Make sure that docker-compose is installed in the yaml script. Also make it manually execcutable for now for testing purposes.

---

_**Assistant**_



---

I'll update the workflow file to install Docker Compose and make it manually executable.

---

```diff
    pull_request:
      branches: [ main, master ]
+   workflow_dispatch:
+     # Allows manual triggering of the workflow
  
  jobs:
```

```diff
        uses: docker/setup-buildx-action@v2
      
+     - name: Install Docker Compose
+       run: |
+         sudo apt-get update
+         sudo apt-get install -y docker-compose
+         docker-compose --version
+     
      - name: Start services with docker-compose
        run: |
```

---

I've updated the GitHub Actions workflow file to:

1. Add a `workflow_dispatch` trigger that allows you to manually run the workflow from the GitHub Actions UI
2. Include a step to explicitly install Docker Compose before using it

Now you can:
- Run the workflow manually from the GitHub Actions tab in your repository
- Be sure that Docker Compose is properly installed on the runner before attempting to use it

This makes the workflow more reliable and gives you the flexibility to trigger test runs manually when needed.

---

