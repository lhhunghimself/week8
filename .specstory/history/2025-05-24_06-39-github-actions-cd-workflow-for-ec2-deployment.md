<!-- Generated by SpecStory -->

# GitHub Actions CD Workflow for EC2 Deployment (2025-05-23 23:39:28)

_**User**_

create a file .github/workflows/cd.yml which will deploy the workflow on the ec2 instance which executes on a manual invoke. .Log into the ec2 instance using my pem file, and see if the github repo directory exists. If it does not, clone it. If it does cd to it. If there is a docker-compose set up and running run docker-compose down. Then pull the latest changes and run docker compose up in production mode, building the latest changes. Create .env from secrets in github. 

---

_**Assistant**_

<think>
The user is asking to create a Continuous Deployment (CD) workflow file that will deploy the application to an EC2 instance when manually triggered. Let me plan out the structure of this GitHub Actions workflow file:

1. Name the workflow "CD Deployment"
2. Configure it to run on manual trigger (workflow_dispatch)
3. Set up a job that:
   - Connects to the EC2 instance using SSH with a PEM file
   - Checks if the GitHub repo directory exists
   - Clones it if it doesn't exist, or navigates to it if it does
   - Stops any running docker-compose setup
   - Pulls the latest changes from the repository
   - Creates the .env file from GitHub Secrets
   - Starts docker-compose in production mode

For SSH connection, we'll need to:
- Store the PEM file content as a GitHub secret
- Set up the EC2 host, username, and port as GitHub secrets

For the .env file, we'll need to create it from GitHub secrets that match the environment variables in the .env file the user shared.

Let's create the workflow file:
</think>

# Creating a CD Workflow for EC2 Deployment

I'll create a GitHub Actions workflow file that will deploy your application to an EC2 instance when manually triggered.

```yaml:.github/workflows/cd.yml
name: CD Deployment

on:
  workflow_dispatch:
    inputs:
      ec2_instance_ip:
        description: 'EC2 Instance IP Address (optional)'
        required: false
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Configure SSH
      run: |
        mkdir -p ~/.ssh/
        echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2.pem
        chmod 600 ~/.ssh/ec2.pem
        ssh-keyscan -H ${{ secrets.EC2_HOST || inputs.ec2_instance_ip }} >> ~/.ssh/known_hosts
      
    - name: Deploy to EC2
      run: |
        # Use the IP from secrets or from workflow input
        EC2_HOST="${{ secrets.EC2_HOST || inputs.ec2_instance_ip }}"
        
        # SSH into the EC2 instance and run deployment steps
        ssh -i ~/.ssh/ec2.pem ${{ secrets.EC2_USER }}@${EC2_HOST} << 'EOF'
          # Set repository directory
          REPO_DIR="${{ secrets.REPO_DIR || 'app' }}"
          
          # Check if repository directory exists
          if [ ! -d "$REPO_DIR" ]; then
            echo "Repository directory doesn't exist. Cloning..."
            git clone ${{ secrets.REPO_URL }} $REPO_DIR
            cd $REPO_DIR
          else
            echo "Repository directory exists. Navigating to it..."
            cd $REPO_DIR
            
            # Check if docker-compose is running and stop it
            if docker-compose ps 2>/dev/null | grep -q Up; then
              echo "Stopping existing docker-compose setup..."
              docker-compose --profile production down
            fi
            
            # Pull latest changes
            echo "Pulling latest changes..."
            git pull
          fi
          
          # Create .env file from GitHub secrets
          echo "Creating .env file..."
          cat > .env << ENVEOF
          FLASK_APP="${{ secrets.FLASK_APP || 'app.py' }}"
          FLASK_DEBUG="${{ secrets.FLASK_DEBUG || '0' }}"
          SECRET_KEY="${{ secrets.FLASK_SECRET_KEY }}"
          GITHUB_OAUTH_CLIENT_ID="${{ secrets.GITHUB_OAUTH_CLIENT_ID }}"
          GITHUB_OAUTH_CLIENT_SECRET="${{ secrets.GITHUB_OAUTH_CLIENT_SECRET }}"
          OAUTHLIB_INSECURE_TRANSPORT="${{ secrets.OAUTHLIB_INSECURE_TRANSPORT || '0' }}"
          POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
          POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
          POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
          POSTGRES_PORT="${{ secrets.POSTGRES_PORT || '5432' }}"
          MAPBOX_ACCESS_TOKEN="${{ secrets.MAPBOX_ACCESS_TOKEN }}"
          TRIPADVISOR_API_KEY="${{ secrets.TRIPADVISOR_API_KEY }}"
          ENVEOF
          
          # Start docker-compose in production mode
          echo "Starting docker-compose in production mode..."
          docker-compose --profile production up -d --build
          
          echo "Deployment completed!"
        EOF
```

## Setup Instructions

Before you can use this workflow, you need to set up the following secrets in your GitHub repository:

1. `EC2_SSH_KEY`: The content of your .pem file for SSH access to your EC2 instance
2. `EC2_HOST`: The hostname or IP address of your EC2 instance (optional if you want to provide it when triggering the workflow)
3. `EC2_USER`: The username for SSH access (typically "ec2-user", "ubuntu", etc.)
4. `REPO_URL`: The URL of your Git repository
5. `REPO_DIR`: (Optional) The directory where the repository should be cloned on the EC2 instance

Additionally, you should add secrets for all the environment variables in your .env file:

- `FLASK_SECRET_KEY`
- `GITHUB_OAUTH_CLIENT_ID`
- `GITHUB_OAUTH_CLIENT_SECRET`
- `POSTGRES_USER`
- `POSTGRES_PASSWORD`
- `POSTGRES_DB`
- `MAPBOX_ACCESS_TOKEN`
- `TRIPADVISOR_API_KEY`

## How to Use

1. Add the secrets to your GitHub repository (Settings > Secrets and variables > Actions)
2. Go to the "Actions" tab in your GitHub repository
3. Select the "CD Deployment" workflow
4. Click "Run workflow"
5. Optionally provide an EC2 instance IP if not using the secret
6. Click "Run workflow" again to start the deployment

This workflow will connect to your EC2 instance, check for the repository, clone or update it, set up the environment variables, and run docker-compose in production mode.

---

_**User**_

# Use the IP from secrets or from workflow input
  EC2_HOST="***
  "
  
  # SSH into the EC2 instance and run deployment steps
  ssh -i ~/.ssh/ec2.pem ***@${EC2_HOST} << 'EOF'
    # Set repository directory
    REPO_DIR="***"
    
    # Check if repository directory exists
    if [ ! -d "$REPO_DIR" ]; then
      echo "Repository directory doesn't exist. Cloning..."
      git clone lhhunghimself/week8 $REPO_DIR
      cd $REPO_DIR
    else
      echo "Repository directory exists. Navigating to it..."
      cd $REPO_DIR
      
      # Check if docker-compose is running and stop it
      if docker-compose ps 2>/dev/null | grep -q Up; then
        echo "Stopping existing docker-compose setup..."
        docker-compose --profile production down
      fi
      
      # Pull latest changes
      echo "Pulling latest changes..."
      git pull
    fi
    
    # Create .env file from GitHub secrets
    echo "Creating .env file..."
    cat > .env << ENVEOF
    FLASK_APP="app.py"
    FLASK_DEBUG="0"
    SECRET_KEY="***"
    GITHUB_OAUTH_CLIENT_ID=""
    GITHUB_OAUTH_CLIENT_SECRET=""
    OAUTHLIB_INSECURE_TRANSPORT="0"
    POSTGRES_USER="***"
    POSTGRES_PASSWORD="***"
    POSTGRES_DB="***"
    POSTGRES_PORT="***"
    MAPBOX_ACCESS_TOKEN="***"
    TRIPADVISOR_API_KEY="***"
    ENVEOF
    
    # Start docker-compose in production mode
    echo "Starting docker-compose in production mode..."
    docker-compose --profile production up -d --build
    
    echo "Deployment completed!"
  EOF
  shell: /usr/bin/bash -e {0}
Pseudo-terminal will not be allocated because stdin is not a terminal.
Host key verification failed.
Error: Process completed with exit code 255.

---

_**Assistant**_

<think>
The error message shows that the SSH connection to the EC2 instance is failing with "Host key verification failed". This is a common SSH error that occurs when:

1. The SSH key being used is invalid or improperly formatted
2. The host key verification is failing because the remote host's key isn't in the known_hosts file or has changed

Let's fix the workflow to address this issue:

1. Make sure we're correctly handling the SSH key 
2. Ensure we're properly adding the host to known_hosts
3. Consider using SSH's StrictHostKeyChecking=no option for simplicity in CI/CD environments
</think>

# Fixing SSH Connection Issues in CD Workflow

The error you're encountering is a host key verification failure, which is preventing the SSH connection to your EC2 instance. Let's fix your CD workflow:

```yaml:.github/workflows/cd.yml
name: CD Deployment

on:
  workflow_dispatch:
    inputs:
      ec2_instance_ip:
        description: 'EC2 Instance IP Address (optional)'
        required: false
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Configure SSH
      run: |
        mkdir -p ~/.ssh/
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/ec2.pem
        chmod 600 ~/.ssh/ec2.pem
        # Add StrictHostKeyChecking=no to avoid host key verification failures
        echo -e "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config
        chmod 600 ~/.ssh/config
      
    - name: Deploy to EC2
      run: |
        # Use the IP from secrets or from workflow input
        EC2_HOST="${{ secrets.EC2_HOST || inputs.ec2_instance_ip }}"
        
        # SSH into the EC2 instance and run deployment steps
        ssh -i ~/.ssh/ec2.pem ${{ secrets.EC2_USER }}@${EC2_HOST} << 'ENDSSH'
          # Set repository directory
          REPO_DIR="${{ secrets.REPO_DIR || 'app' }}"
          
          # Check if repository directory exists
          if [ ! -d "$REPO_DIR" ]; then
            echo "Repository directory doesn't exist. Cloning..."
            git clone https://github.com/${{ github.repository }}.git $REPO_DIR
            cd $REPO_DIR
          else
            echo "Repository directory exists. Navigating to it..."
            cd $REPO_DIR
            
            # Check if docker-compose is running and stop it
            if docker-compose ps 2>/dev/null | grep -q Up; then
              echo "Stopping existing docker-compose setup..."
              docker-compose --profile production down
            fi
            
            # Pull latest changes
            echo "Pulling latest changes..."
            git pull
          fi
          
          # Create .env file from GitHub secrets
          echo "Creating .env file..."
          cat > .env << ENVEOF
          FLASK_APP="${{ secrets.FLASK_APP || 'app.py' }}"
          FLASK_DEBUG="${{ secrets.FLASK_DEBUG || '0' }}"
          SECRET_KEY="${{ secrets.SECRET_KEY }}"
          GITHUB_OAUTH_CLIENT_ID="${{ secrets.GITHUB_OAUTH_CLIENT_ID }}"
          GITHUB_OAUTH_CLIENT_SECRET="${{ secrets.GITHUB_OAUTH_CLIENT_SECRET }}"
          OAUTHLIB_INSECURE_TRANSPORT="${{ secrets.OAUTHLIB_INSECURE_TRANSPORT || '0' }}"
          POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
          POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
          POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
          POSTGRES_PORT="${{ secrets.POSTGRES_PORT || '5432' }}"
          MAPBOX_ACCESS_TOKEN="${{ secrets.MAPBOX_ACCESS_TOKEN }}"
          TRIPADVISOR_API_KEY="${{ secrets.TRIPADVISOR_API_KEY }}"
          ENVEOF
          
          # Start docker-compose in production mode
          echo "Starting docker-compose in production mode..."
          docker-compose --profile production up -d --build
          
          echo "Deployment completed!"
        ENDSSH
```

## Key Changes:

1. **Added SSH Config**: I've added an SSH config file that disables strict host key checking. This is a common approach for CI/CD pipelines to avoid host key verification failures.

2. **Fixed Repository URL**: Changed the git clone command to use the full GitHub URL with https protocol, which should work without authentication for public repositories.

3. **Changed Heredoc Delimiter**: Changed `EOF` to `ENDSSH` to be more descriptive and avoid potential conflicts.

## Additional Considerations:

1. **GitHub Authentication**: If your repository is private, you'll need to set up authentication for the git clone. You can either:
   - Use a GitHub Personal Access Token: Add `https://username:token@github.com/...` 
   - Use SSH authentication with deploy keys

2. **SSH Key Format**: Ensure your `SSH_PRIVATE_KEY` secret is correctly formatted, including all line breaks.

3. **Variable Expansion**: If you need environment variable expansion within the heredoc, you might need to adjust the quoting around 'ENDSSH'.

4. **Debugging**: If you continue to have issues, add some debug steps to print more information about the SSH connection, like:
   ```yaml
   - name: Debug SSH
     run: |
       ssh -v -i ~/.ssh/ec2.pem ${{ secrets.EC2_USER }}@${EC2_HOST} echo "SSH connection successful"
   ```

---

